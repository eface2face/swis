<script>
	
	//Reverse map <id,node>
	var map = {};
	var reverse = new WeakMap();
	
(function(){	
	var maxId = 1;
	var maxMediaRuleId = 1;
	var source;
	var hovered;
	
	
	//Media rules
	var mediarules = {};
	
	var remoteCursor;
	function showRemoteCursor(x,y) {
		//Check if first cursor
		if (!remoteCursor)
		{
			//Create new element
			remoteCursor = document.createElement("div");
			//Set absolute positioning
			remoteCursor.style["position"] = "absolute";
			remoteCursor.style["width"] = "150px";
			remoteCursor.style["height"] = "25px";
			remoteCursor.style["border"] = "1px black solid";
			remoteCursor.style["background-color"] = "green";
			remoteCursor.style["color"] = "white";
			remoteCursor.style["margin"] = "0px";
			remoteCursor.style["padding"] = "0px";
			remoteCursor.style["z-index"] = "99999999999999999999999999";
			//Set text
			remoteCursor.innerHTML = "^Remote Cursor";
			//Insert into
			document.documentElement.appendChild(remoteCursor);
		}
		//Set new position
		remoteCursor.style["left"] = x + "px";
		remoteCursor.style["top"] =  y + "px";
	}
	
	function resolveCSSURLs(css,base) {
		var ini = 0;
		var lower = css.toLowerCase();
		var output = "";
		
		//Find first url occurrence
		var i = lower.indexOf("url(",ini);
		
		//Replace all
		while (i!==-1){
			//Skip url(
			i += "url(".length;
			//Append to output
			output += css.substring(ini,i);
			//Move ini
			ini = i;
			//Get end
			var j = lower.indexOf(")",ini);
			//Get url
			var url = css.substring(i,j).trim();
			//Remove start and end "'
			if (url.charAt(0)==='\'' || url.charAt(0)==='"')
				//remove both ends
				url = url.substring(1,url.length-1).trim();
			//Create new url
			output += new URL(url,base);
			//Append end of url
			output += ")";
			//Move end
			ini = j+1;
			//Find first url occurrence
			var i = lower.indexOf("url(",ini);
		}
		//Copy the rest
		output += css.substr(ini,css.length);
		//Return rebased css
		return output;
	}
	

	function hover(element) {
		//Check if it was the same
		if (element!==hovered)
		{
			//Unhover
			if (hovered)
			{
				var el = hovered;
				//Clear all recurisvelly
				while (el)
				{
					//Remove data
					if(el.dataset) delete(el.dataset['hover']);
					//Un hover parent
					el = el.parentNode;
				}
			}
			//Now hover element and parets
			if (element) {
				var el = element;
				//Set all recurisvelly
				while (el)
				{
					//Set data
					if(el.dataset) el.dataset['hover']=true;
					//Un hover parent
					el = el.parentNode;
				}
			}
			//Set new hovered
			hovered = element;
		}
	}
	
	function add(id,element) {
		//Add element to map
		map[id] = element;
		//Add to reverse map also
		reverse.set(element,id);
	}

	function replace(id,element) {
		//Get old
		var old = map[id];
		//Delete old from map
		reverse.delete(old);
		//Set new value in map
		map[id] = element;
		//Add to reverse map also
		reverse.set(element,id);
	}
	//Populate map with ids
	function populate(element){
		//Add element to map
		add(maxId++,element);
		//For each child node
		for (var i=0;i<element.childNodes.length;++i)
		{
			
			if (element.childNodes[i].dataset) element.childNodes[i].dataset["swisId"] =maxId;
			
			//Ignore doctype
			if (element.childNodes[i].nodeType!==10)
				//Get child id
				populate(element.childNodes[i]);
		}
	}
	
	function releaseElement(element) {
		//Get id
		var id = reverse.get(element);
		//Add element to map
		delete(map[id]);
		//Delete from reverse map
		reverse.delete(element);
		//For each child node
		for (var i=0;i<element.childNodes.length;++i)
			//Get child
			releaseElement(element.childNodes[i]);
	}
	
	//Release map with ids
	function release(id){
		//Get element
		var element = map[id];
		//Add element to map
		delete(map[id]);
		//Delete from reverse map
		reverse.delete(element);
		//For each child node
		for (var i=0;i<element.childNodes.length;++i)
			//Get child
			releaseElement(element.childNodes[i]);
	}
	
	//Handle media queries and hover on elements
	function processStyles() {
		var queries = {};
		//Now get the styles
		for (var x = 0; x < document.styleSheets.length; x++) 
		{
			var rules = document.styleSheets[x].cssRules;
			var i = 0;
			
			//We are removing items inside the loop
			while(rules && rules.length && i<rules.length) 
			{
				//Check if it is a media rule
				if (rules[i] instanceof CSSMediaRule)
				{
					var html = "";
					//And append all the child styles
					for (var j = 0;j<rules[i].cssRules.length; j++)
						//Append HTML
						html = rules[i].cssRules[j].cssText + "\n";
					//Create new element
					var el = document.createElement("style");
					//Set it to disabled when loaded
					el.onload = function(){ el.disabled = true; };
					//Append html styles
					el.innerHTML = html;
					//Append to head (Do it async??)
					document.querySelector("head").appendChild(el).disabled;
					//Get id for this media rule
					var id = maxMediaRuleId++;
					//Append media query
					mediarules[id] = {
						element: el,
						media: rules[i].media.mediaText
					};
					//request update
					queries[id] = rules[i].media.mediaText;
					//Remove the media rules
					document.styleSheets[x].removeRule(i);
				} else if (rules[i] instanceof CSSStyleRule) {
					//Replace pseudo classes
					rules[i].selectorText = rules[i].selectorText.replace(":hover","[data-hover]");
					//Next
					i++;
				} else {
					//Leave it as it is
					i++;
				}
			}
		}
		//Send event
		var messages = [{
			m: 0,
			q: queries
		}];
		//POst message back to source
		source.postMessage(JSON.stringify(messages), "*");
	}
	
	
	
	window.addEventListener("message", function(message){
		//Get source
		source = message.source;

		//Create HTML
		document.open();
		document.write(message.data);
		document.close();
		
		//Pupulate ids
		populate(document);
		
		//Process styles
		processStyles();
		
		//Listen for message changes again, as listener has been desroyed 
		window.addEventListener("message", function(message){
			//Get list of mutations 
			var mutations = JSON.parse(message.data);
			//List of deleted nodes
			var deleted = {};
			//For each mutation
			for (var j=0;j<mutations.length;++j)
			{
				try {
					var mutation = mutations[j];
					//console.log(mutation);
					switch(mutation.m)
					{
						case 0:
							console.log("ChildList",mutation);
							//Get target
							var target = map[mutation.t];
							//Get previous
							var previous = map[mutation.p];
							//Get next
							var next = map[mutation.n];
							//Deleted elements
							for (var i=0;i<mutation.d.length;i++)
							{
								//Add to the deleted ones
								deleted[mutation.d[i]] = true;
								//Remove node
								map[mutation.d[i]].remove();
							}
							//Added elements
							for (var i=0;i<mutation.a.length;i++)
							{
								//Check if it is an id or a new element
								if (typeof mutation.a[i] === "string")
								{
									//Create node from HTML
									var node = createElementFromHTML(mutation.a[i]);
									//Pupulate it
									populate(node);
									//Add
									target.insertBefore(node,next);
								} else {
									//Delete from deleted (jic)
									delete(deleted[mutation.a[i]]);
									//Add it
									target.insertBefore(map[mutation.a[i]],next);
								}
							}
							break;
						case 1:
							console.log("Atrribute",mutation);
							//Get target
							var target = map[mutation.t];
							//Set data
							target.setAttribute(mutation.k,mutation.v);
							break;
						case 2:
							console.log("CharData",mutation);
							//Get target
							var target = map[mutation.t];
							//Set data
							target.data = mutation.d;
							break;
						//Hovered
						case 3:
							console.log("Hover",mutation);
							//Get target
							var target = map[mutation.t];
							//Hover target
							hover(target);
							break;	
						//Focus
						case 4:
							console.log("Focus",mutation);
							//Get target
							var target = map[mutation.t];
							//Focus
							target.focus();
							break;	
						//Blur
						case 5:
							console.log("Blur",mutation);
							//Get target
							var target = map[mutation.t];
							//Blur focus
							target.blur();
							break;
						//input
						case 6:
							console.log("Input",mutation);
							//Get target
							var target = map[mutation.t];
							//Set value
							target.value = mutation.v;
							break;
						//Set exteranl CSS
						case 7:
							console.log("External CSS content",mutation.t);
							//Get target
							var target = map[mutation.t];
							//Create new style
							var style = document.createElement("style");
							//Set all attributes
							for (var k in target.attributes)
								//Clone in style element
								style[k] = target[k];
							//Set css
							style.innerHTML = resolveCSSURLs(mutation.c,mutation.h);
							//Replace in parent node the target by element
							target.parentNode.replaceChild(style,target);
							//Set the  new element in map
							replace(mutation.t,style);
							//Process styles on next run
							setTimeout(processStyles,0);
							//Reset
							break;
						//External css fallback
						case 8:
							console.log("External CSS link",mutation.t);
							//Get target
							var target = map[mutation.t];
							//Process styles on load
							target.onload = processStyles;
							//Set href
							target.href = mutation.h;
							break;
						//Queries match
						case 9:
							console.log("Queries match",mutation);
							//For all changes
							for (var id in mutation.q)
								//Enable/disable associated element
								mediarules[id].element.disabled = !mutation.q[id];
							break;
						//Resized
						case 10:
							console.log("Resized",mutation);
							/*
							//Get viewport
							var viewport = document.querySelector("meta[name=viewport]");
							//If not found, create empty one
							if (!viewport)
							{
								//Create it
								viewport = document.createElement("meta");
								//Set name
								viewport.name = "viewport";
								//Add it to document
								document.querySelector("head").appendChild(viewport);
							}
							//Set content
							viewport.content = "width="+mutation.s[0]+",height="+mutation.s[1];
							*/
						       window.resizeTo(mutation.s[0],mutation.s[1]);
						       break;
						//Rebase
						case 11:
							console.log("Rebase",mutation);
							//Get base element
							var base = document.querySelector("base");
							//Check if it exist already
							if (!base)
							{
								//Craete base element
								base = document.createElement("base");
								//Set href to documenbt location
								base.setAttribute("href", mutation.h);
								//Append to head in the cloned doc
								document.querySelector("head").appendChild(base);
							} else {
								//JUst change href
								base.setAttribute("href", mutation.h);
							}
							break;
						//Mouse cursor
						case 12:
							console.log("Mouse cursor",mutation);
							//Move cursor
							showRemoteCursor(mutation.x,mutation.y);
							break;
						default:
							console.log("unknown mutation",mutation);
					}
				} catch (e) {
					console.error(e);
				}
			}
			//Garbage collect
			for (var id in deleted)
				//Release delete node refs
				release(id);
		});
		
		//Send back mouse position
		document.addEventListener ("mousemove", function (event) {
			var x = event.pageX;
			var y = event.pageY;
			var messages=[{
					m: 1,
					x: x,
					y: y
				}];
			//POst message
			source.postMessage(JSON.stringify(messages), "*");
		},true);
	});
	
	function createElementFromHTML (html) {
		//Default wrap
		var wrap = [0,"",""];
		// From jquery
		var wrapMap = {
			option: [ 1, "<select multiple='multiple'>", "</select>" ],
			legend: [ 1, "<fieldset>", "</fieldset>" ],
			area: [ 1, "<map>", "</map>" ],
			param: [ 1, "<object>", "</object>" ],
			thead: [ 1, "<table>", "</table>" ],
			tr: [ 2, "<table><tbody>", "</tbody></table>" ],
			col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
			td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ]
		};
		
		//Check if we need to wrap
		for (var tag in wrapMap) 
		{
			//Check if it is this element
			if (html.substr(1,tag.length).toLowerCase()===tag)
			{
				//Store wrap
				wrap = wrapMap[tag];
				//Found
				break;
			}
		}
		
		//Parse
		var tmp = document.implementation.createHTMLDocument();
		//Append wrap and parse
		tmp.body.innerHTML = wrap[1]+html+wrap[2];
		//Find element
		var element = tmp.body.childNodes[0];
		//Unwrap
		for (var i=0;i<wrap[0];++i)
			//Get child
			element = element.childNodes[0];
		//Return element
		return element;
	};
	
	//Remove this script tag from DOM
	document.removeChild(document.children[0]);
})();
</script>